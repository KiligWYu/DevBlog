<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Kilig 的博客 | 代码之外"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>Concurrency 备忘清单 | 𝕶𝖎𝖑𝖎𝖌'𝖘 𝕭𝖑𝖔𝖌</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script src="https://www.googletagmanager.com/gtag/js?id=G-YLMXL0J5N0" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-YLMXL0J5N0');
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 7.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Concurrency 备忘清单</h1><a id="logo" href="/.">𝕶𝖎𝖑𝖎𝖌'𝖘 𝕭𝖑𝖔𝖌</a><p class="description">代码之外</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/categories/%E7%A2%8E%E5%91%A8%E6%8A%A5/"><i class="fa fa-envelope"> 碎周报</i></a><a href="/categories/Learn-in-Public/"><i class="fa fa-leanpub"> Learn in Public</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">Concurrency 备忘清单</h1><div class="post-meta">2024-07-06</div><!-- if theme.disqus.enable == true// a.disqus-comment-count(data-disqus-identifier=page.path, href=url_for(page.path) + '#disqus_thread')--><div class="post-content"><ul>
<li><a href="#%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0">异步函数</a>
<ul>
<li><a href="#%E5%BC%82%E6%AD%A5%E6%8A%9B%E5%87%BA%E5%87%BD%E6%95%B0">异步抛出函数</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0">第一个异步函数</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%83%BD%E6%88%90%E6%9C%AC">调用异步函数的性能成本</a></li>
</ul>
</li>
<li><a href="#%E5%BC%82%E6%AD%A5%E5%B1%9E%E6%80%A7">异步属性</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-async-let-%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0">使用 async let 调用异步函数</a>
<ul>
<li><a href="#wait-%E5%92%8C-async-let-%E7%9A%84%E5%8C%BA%E5%88%AB">wait 和 async let 的区别</a></li>
<li><a href="#async-var">async var？</a></li>
</ul>
</li>
<li><a href="#continuations">Continuations</a>
<ul>
<li><a href="#%E5%8F%AF%E4%BB%A5%E6%8A%9B%E5%87%BA%E9%94%99%E7%9A%84-continuations">可以抛出错的 Continuations</a></li>
<li><a href="#%E5%AD%98%E5%82%A8-continuations">存储 Continuations</a></li>
</ul>
</li>
<li><a href="#%E5%9C%A8%E4%B8%8D%E6%94%AF%E6%8C%81%E5%B9%B6%E5%8F%91%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8">在不支持并发的函数中进行异步调用</a></li>
<li><a href="#sequence-asyncsequence-%E5%92%8C-asyncstream">Sequence、AsyncSequence 和 AsyncStream</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8-for-wait-%E5%BE%AA%E7%8E%AF-asyncsequence">使用 for wait 循环 AsyncSequence</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-map-filter-%E7%AD%89%E6%93%8D%E4%BD%9C-asyncsequence">使用 map ()、filter () 等操作 AsyncSequence</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E5%BA%8F%E5%88%97">创建自定义异步序列</a></li>
<li><a href="#%E5%B0%86-asyncsequence-%E8%BD%AC%E6%8D%A2%E4%B8%BA-sequence">将 AsyncSequence 转换为 Sequence</a></li>
</ul>
</li>
<li><a href="#task">Task</a>
<ul>
<li><a href="#task-%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C">Task 的创建和运行</a></li>
<li><a href="#detached-task">Detached Task</a></li>
<li><a href="#%E4%BB%8E%E4%BB%BB%E5%8A%A1%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%9C">从任务中获取结果</a></li>
<li><a href="#%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7">任务优先级</a></li>
<li><a href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8D%87%E7%BA%A7">优先级升级</a></li>
<li><a href="#%E5%8F%96%E6%B6%88%E4%BB%BB%E5%8A%A1">取消任务</a></li>
<li><a href="#%E4%BC%91%E7%9C%A0%E4%BB%BB%E5%8A%A1">休眠任务</a></li>
<li><a href="#%E4%B8%BB%E5%8A%A8%E6%9A%82%E5%81%9C%E4%BB%BB%E5%8A%A1">主动暂停任务</a></li>
</ul>
</li>
<li><a href="#task-group">Task Group</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%B9%B6%E5%90%91%E5%85%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1">创建任务组并向其中添加任务</a></li>
<li><a href="#%E5%8F%96%E6%B6%88%E4%BB%BB%E5%8A%A1%E7%BB%84">取消任务组</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E7%BB%93%E6%9E%9C%E7%B1%BB%E5%9E%8B">如何处理任务组中的不同结果类型</a></li>
</ul>
</li>
<li><a href="#swiftui-%E4%B8%AD%E7%9A%84-task-%E4%BF%AE%E9%A5%B0%E7%AC%A6">SwiftUI 中的 task() 修饰符</a></li>
<li><a href="#actors">Actors</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%9A%94%E7%A6%BB">函数参数隔离</a></li>
<li><a href="#%E9%83%A8%E5%88%86%E9%9A%94%E7%A6%BB">部分隔离</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-mainactor-%E5%9C%A8%E4%B8%BB%E9%98%9F%E5%88%97%E4%B8%8A%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81">使用 @MainActor 在主队列上运行代码</a></li>
<li><a href="#%E5%85%A8%E5%B1%80-actor-%E6%8E%A8%E6%96%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">全局 actor 推断的工作原理</a></li>
<li><a href="#actor-%E8%B7%B3%E8%B7%83">actor 跳跃</a></li>
<li><a href="#actors-classes-and-structs-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">actors, classes, and structs 之间的区别</a></li>
</ul>
</li>
<li><a href="#%E5%8F%A6%E8%A7%81">另见</a></li>
</ul>
<p>本篇是 <a target="_blank" rel="noopener" href="https://www.hackingwithswift.com/quick-start/concurrency">Swift Concurrency by Example</a> 的学习笔记。简要记录，备忘清单。推荐看原教程，配合代码示例更佳清晰易懂。</p>
<hr />
<blockquote>
<p>Concurrency is about dealing with many things at once, parallelism is about doing many things at once. Concurrency is a way to structure things so you can maybe use parallelism to do a better job. —— Rob Pike</p>
</blockquote>
<p>默认情况下，所有 Swift 函数都是同步的。同步函数会导致阻塞，从而导致性能问题。异步函数不会阻塞。</p>
<h2 id="异步函数"><a class="markdownIt-Anchor" href="#异步函数"></a> 异步函数</h2>
<p>通过关键字 <code>async</code> 来创建异步函数，在异步函数内部，可以使用 <code>await</code> 关键字来调用其他异步函数。</p>
<ul>
<li><code>async</code> 是函数类型的一部分。</li>
<li>用 <code>async</code> 标记函数意味着它可能会执行异步工作，而不是必须执行异步工作。同样， <code>throws</code> 也是如此 - 通过函数的某些路径可能会抛出异常，但其他路径可能不会。</li>
</ul>
<p>当使用 <code>await</code> 调用异步函数时，我们标记了一个挂起点，这是函数可以挂起自身的地方（实际上是停止运行），以便可以进行其他工作。在未来的某个时刻，该函数的工作完成，Swift 会将其从 “假死” 般的状态中唤醒，并继续工作。</p>
<ul>
<li>当一个异步函数被挂起时，所有调用它的异步函数也会被挂起。异步函数具有常规同步函数所没有的特殊暂停能力。正是由于这个原因，同步函数无法直接调用异步函数。</li>
<li>一个函数可以根据需要多次挂起，使用 <code>await</code> 关键字。</li>
<li>被挂起的函数不会阻塞它正在运行的线程，而是放弃该线程，以便 Swift 可以做其他工作。</li>
<li>当函数恢复时，它可能与以前一样在同一个线程上运行，但也可能不是。</li>
</ul>
<h3 id="异步抛出函数"><a class="markdownIt-Anchor" href="#异步抛出函数"></a> 异步抛出函数</h3>
<p>把函数标记为 <code>async throws</code> ，使用 <code>try await</code> 调用该函数。注意关键字的顺序，在函数定义中是 “异步，抛出”，但在调用站点是 “抛出，异步”。<code>try await</code> 不仅比 <code>await try</code> 更容易阅读，而且它也更能反映代码执行时实际发生的情况：我们正在等待某些工作完成，以及它何时完成完成后我们将检查它是否最终抛出错误。</p>
<blockquote>
<p>This order restriction is arbitrary, but it’s not harmful, and it eliminates the potential for stylistic debates.</p>
</blockquote>
<h3 id="第一个异步函数"><a class="markdownIt-Anchor" href="#第一个异步函数"></a> 第一个异步函数</h3>
<p>如果只有异步函数可以调用其他异步函数，那么是什么调用了第一个异步函数？</p>
<p>有三种主要方式：</p>
<ol>
<li>在使用 <code>@main</code> 属性的简单命令行程序中，你可以将 <code>main()</code> 方法声明为异步方法。这意味着您的程序将立即启动到异步函数，因此你可以自由调用其他异步函数。</li>
<li>在使用 SwiftUI 等构建的应用程序中，框架本身有多个可以触发异步函数的地方。例如， <code>refreshable()</code> 和 <code>task()</code> 修饰符都可以自由调用异步函数。</li>
<li>Swift 提供了专用的 <code>Task</code> API。</li>
</ol>
<h3 id="调用异步函数的性能成本"><a class="markdownIt-Anchor" href="#调用异步函数的性能成本"></a> 调用异步函数的性能成本</h3>
<p>同步和异步函数在内部使用不同的调用约定，异步变体的效率稍低。</p>
<p>每当我们使用 <code>await</code> 调用异步函数时，我们都会在代码中标记一个潜在的挂起点，Swift 无法在编译时判断 <code>await</code> 调用是否会挂起，运行时发生的情况取决于调用是否挂起：</p>
<ul>
<li>如果发生暂停，那么 Swift 将暂停该函数及其所有调用者，这会产生很小的性能成本。</li>
<li>如果没有发生暂停，则不会发生暂停，并且您的函数将继续以与同步函数相同的效率和时序运行。</li>
</ul>
<p>异步函数还有一个副作用：使用 <code>await</code> 不会导致您的代码在继续之前等待一个运行循环。相较于 <code>DispatchQueue.main.async &#123; … &#125;</code> 使用 <code>await</code> ，代码将立即执行。</p>
<h2 id="异步属性"><a class="markdownIt-Anchor" href="#异步属性"></a> 异步属性</h2>
<p>Swift 中，只读计算属性也可以是异步的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contents: <span class="type">T</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// more code to come</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-async-let-调用异步函数"><a class="markdownIt-Anchor" href="#使用-async-let-调用异步函数"></a> 使用 async let 调用异步函数</h2>
<p>有时您想同时运行多个异步操作，然后等待它们的结果返回，最简单的方法是使用 <code>async let</code> 。比如同时发起两个网络请求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">loadData</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">let</span> (userData, <span class="keyword">_</span>) <span class="operator">=</span> <span class="type">URLSession</span>.shared.data(from: <span class="type">URL</span>(string: <span class="string">&quot;https://hws.dev/user-24601.json&quot;</span>)<span class="operator">!</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">let</span> (messageData, <span class="keyword">_</span>) <span class="operator">=</span> <span class="type">URLSession</span>.shared.data(from: <span class="type">URL</span>(string: <span class="string">&quot;https://hws.dev/user-messages.json&quot;</span>)<span class="operator">!</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// more code to come</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对上面的代码：</p>
<ul>
<li>即使 <code>data(from:)</code> 方法是异步的，我们也不需要在它之前使用 <code>await</code> 因为这是由 <code>async let</code> 暗示的。</li>
<li><code>data(from:)</code> 方法也会抛出异常，但我们不需要使用 <code>try</code> 来执行它，因为它会被推迟到我们真正想要读取其返回值的时候。Swift 编译器将自动跟踪哪些 <code>async let</code> 常量可能引发错误，并在读取其值时强制使用 <code>try</code> 。</li>
<li>这两个网络调用都会立即开始，但可能以任何顺序完成。</li>
</ul>
<h3 id="wait-和-async-let-的区别"><a class="markdownIt-Anchor" href="#wait-和-async-let-的区别"></a> wait 和 async let 的区别</h3>
<p><code>await</code> 会等待工作完成，以便我们可以读取其结果，而 <code>async let</code> 则不会。</p>
<p>例如，如果您想要发出两个网络请求，其中一个请求与另一个请求相关，那么应当使用 <code>await</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first <span class="operator">=</span> <span class="keyword">await</span> requestFirstData()</span><br><span class="line"><span class="keyword">let</span> second <span class="operator">=</span> <span class="keyword">await</span> requestSecondData(using: first)</span><br></pre></td></tr></table></figure>
<p>而如果两个网络请求没有依赖关系，则可以使用 <code>async let</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getAppData</span>() <span class="keyword">async</span> -&gt; ([<span class="type">News</span>], [<span class="type">Weather</span>], <span class="type">Bool</span>) &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">let</span> news <span class="operator">=</span> getNews()</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">let</span> weather <span class="operator">=</span> getWeather()</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">let</span> hasUpdate <span class="operator">=</span> getAppUpdateAvailable()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> (news, weather, hasUpdate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="async-var"><a class="markdownIt-Anchor" href="#async-var"></a> async var？</h3>
<p>Swift 的 <code>async let</code> 语法提供了简短、有用的语法，可以同时运行大量工作，让我们可以稍后等待它们。但是，它只能用作 <code>async let</code> - 不可能使用 <code>async var</code>。</p>
<p>如果使用 <code>async var</code> 异步创建一个变量，然后修改变量的值，那么我们取消了异步工作吗？如果不是，当异步工作完成时，它会覆盖我们的新值吗？即使我们明确设置了值，在读取值时是否仍然需要使用 await ？所以只能使用 <code>async let</code>。</p>
<h2 id="continuations"><a class="markdownIt-Anchor" href="#continuations"></a> Continuations</h2>
<p>使用 Continuations，使我们能够在带有完成处理程序的旧函数和新异步代码之间创建一座桥梁。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/checkedcontinuation"><code>CheckedContinuation</code></a>: A mechanism to interface between synchronous and asynchronous code, logging correctness violations.</li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/unsafecontinuation"><code>UnsafeContinuation</code></a>: A mechanism to interface between synchronous and asynchronous code, without correctness checking.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Message</span>: <span class="title class_">Decodable</span>, <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> from: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> message: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">fetchMessages</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> ([<span class="type">Message</span>]) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://hws.dev/user-messages.json&quot;</span>)<span class="operator">!</span></span><br><span class="line"></span><br><span class="line">  <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, <span class="keyword">_</span>, <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> data &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> messages <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONDecoder</span>().decode([<span class="type">Message</span>].<span class="keyword">self</span>, from: data) &#123;</span><br><span class="line">        completion(messages)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    completion([])</span><br><span class="line">  &#125;.resume()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">fetchMessages</span>() <span class="keyword">async</span> -&gt; [<span class="type">Message</span>] &#123;</span><br><span class="line">  <span class="keyword">await</span> withCheckedContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">    fetchMessages &#123; messages <span class="keyword">in</span></span><br><span class="line">      continuation.resume(returning: messages)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> messages <span class="operator">=</span> <span class="keyword">await</span> fetchMessages()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Downloaded <span class="subst">\(messages.count)</span> messages.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>注意，在程序的每个执行路径中，必须准确地调用一次 resume 方法。 否则会造成 continuation 泄露，</p>
<p>如果您仔细检查了代码并且确定它是正确的，那么将 <code>withCheckedContinuation()</code> 函数替换为对 <code>withUnsafeContinuation()</code> 的调用，其工作原理完全相同方式，但不会增加检查您是否正确使用延续的运行时成本。</p>
<h3 id="可以抛出错的-continuations"><a class="markdownIt-Anchor" href="#可以抛出错的-continuations"></a> 可以抛出错的 Continuations</h3>
<p><code>withCheckedThrowingContinuation()</code> 和 <code>withUnsafeThrowingContinuation()</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Message</span>: <span class="title class_">Decodable</span>, <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> from: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> message: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">fetchMessages</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> ([<span class="type">Message</span>]) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://hws.dev/user-messages.json&quot;</span>)<span class="operator">!</span></span><br><span class="line"></span><br><span class="line">  <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, <span class="keyword">_</span>, <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> data &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> messages <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONDecoder</span>().decode([<span class="type">Message</span>].<span class="keyword">self</span>, from: data) &#123;</span><br><span class="line">        completion(messages)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    completion([])</span><br><span class="line">  &#125;.resume()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An example error we can throw</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">FetchError</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> noMessages</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">fetchMessages</span>() <span class="keyword">async</span> -&gt; [<span class="type">Message</span>] &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">await</span> withCheckedThrowingContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">      fetchMessages &#123; messages <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> messages.isEmpty &#123;</span><br><span class="line">          continuation.resume(throwing: <span class="type">FetchError</span>.noMessages)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          continuation.resume(returning: messages)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      <span class="type">Message</span>(id: <span class="number">1</span>, from: <span class="string">&quot;Tom&quot;</span>, message: <span class="string">&quot;Welcome to MySpace! I&#x27;m your new friend.&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> messages <span class="operator">=</span> <span class="keyword">await</span> fetchMessages()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Downloaded <span class="subst">\(messages.count)</span> messages.&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="存储-continuations"><a class="markdownIt-Anchor" href="#存储-continuations"></a> 存储 Continuations</h3>
<p>通过将 Continuations 存储为属性，我们就可以在多个不同的地方恢复它。</p>
<p>下面以 <code>LocationManager</code> 为例，把 <code>continuation</code> 存储在属性中，位置更新成功或失败是在两个代理方法中，分别在这两个方法中恢复 continuation。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocationManager</span>: <span class="title class_">NSObject</span>, <span class="title class_">ObservableObject</span>, <span class="title class_">CLLocationManagerDelegate</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> locationContinuation: <span class="type">CheckedContinuation</span>&lt;<span class="type">CLLocationCoordinate2D</span>?, <span class="type">Error</span>&gt;?</span><br><span class="line">  <span class="keyword">let</span> manager <span class="operator">=</span> <span class="type">CLLocationManager</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    manager.delegate <span class="operator">=</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">requestLocation</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">CLLocationCoordinate2D</span>? &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">await</span> withCheckedThrowingContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">      locationContinuation <span class="operator">=</span> continuation</span><br><span class="line">      manager.requestLocation()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">locationManager</span>(<span class="keyword">_</span> <span class="params">manager</span>: <span class="type">CLLocationManager</span>, <span class="params">didUpdateLocations</span> <span class="params">locations</span>: [<span class="type">CLLocation</span>]) &#123;</span><br><span class="line">    locationContinuation<span class="operator">?</span>.resume(returning: locations.first<span class="operator">?</span>.coordinate)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">locationManager</span>(<span class="keyword">_</span> <span class="params">manager</span>: <span class="type">CLLocationManager</span>, <span class="params">didFailWithError</span> <span class="params">error</span>: <span class="type">Error</span>) &#123;</span><br><span class="line">    locationContinuation<span class="operator">?</span>.resume(throwing: error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">  <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> locationManager <span class="operator">=</span> <span class="type">LocationManager</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">LocationButton</span> &#123;</span><br><span class="line">      <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> location <span class="operator">=</span> <span class="keyword">try?</span> <span class="keyword">await</span> locationManager.requestLocation() &#123;</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;Location: <span class="subst">\(location)</span>&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;Location unknown.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .frame(height: <span class="number">44</span>)</span><br><span class="line">    .foregroundColor(.white)</span><br><span class="line">    .clipShape(<span class="type">Capsule</span>())</span><br><span class="line">    .padding()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在不支持并发的函数中进行异步调用"><a class="markdownIt-Anchor" href="#在不支持并发的函数中进行异步调用"></a> 在不支持并发的函数中进行异步调用</h2>
<p>通过使用 <code>Task</code> 来解决问题。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">doAsyncWork</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Doing async work&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">doRegularWork</span>() &#123;</span><br><span class="line">  <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> doAsyncWork()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doRegularWork()</span><br></pre></td></tr></table></figure>
<h2 id="sequence-asyncsequence-和-asyncstream"><a class="markdownIt-Anchor" href="#sequence-asyncsequence-和-asyncstream"></a> Sequence、AsyncSequence 和 AsyncStream</h2>
<ul>
<li><code>Sequence</code> 协议，它不断返回值，直到通过返回 <code>nil</code> 终止序列。</li>
<li><code>AsyncSequence</code> 协议几乎与 <code>Sequence</code> 相同，但序列中的每个元素都是异步返回的。
<ul>
<li>从异步序列读取值必须使用 `await</li>
</ul>
</li>
<li>更高级的异步序列（<code>AsyncStream</code>）生成值的速度可能比您读取它们的速度快，在这种情况下，您可以丢弃额外的值或缓存它们以便稍后读取。`</li>
</ul>
<h3 id="使用-for-wait-循环-asyncsequence"><a class="markdownIt-Anchor" href="#使用-for-wait-循环-asyncsequence"></a> 使用 for wait 循环 AsyncSequence</h3>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/url/3767315-lines">URL lines</a>: The URL’s resource data, as an asynchronous sequence of lines of text.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">fetchUsers</span>() <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://hws.dev/users.csv&quot;</span>)<span class="operator">!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">try</span> <span class="keyword">await</span> line <span class="keyword">in</span> url.lines &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Received user: <span class="subst">\(line)</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try?</span> <span class="keyword">await</span> fetchUsers()</span><br></pre></td></tr></table></figure>
<p>使用异步序列可以有效地生成一个迭代器，然后重复调用它的 <code>next()</code> 直到它返回 <code>nil</code> ，此时循环结束。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printUsers</span>() <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://hws.dev/users.csv&quot;</span>)<span class="operator">!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> iterator <span class="operator">=</span> url.lines.makeAsyncIterator()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> line <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> iterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The first user is <span class="subst">\(line)</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">2</span> <span class="operator">...</span> <span class="number">5</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> line <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> iterator.next() &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;User #<span class="subst">\(i)</span>: <span class="subst">\(line)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> remainingResults <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> iterator.next() &#123;</span><br><span class="line">    remainingResults.append(result)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;There were <span class="subst">\(remainingResults.count)</span> other users.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try?</span> <span class="keyword">await</span> printUsers()</span><br></pre></td></tr></table></figure>
<h3 id="使用-map-filter-等操作-asyncsequence"><a class="markdownIt-Anchor" href="#使用-map-filter-等操作-asyncsequence"></a> 使用 map ()、filter () 等操作 AsyncSequence</h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getQuotes</span>() <span class="keyword">async</span> -&gt; <span class="keyword">some</span> <span class="type">AsyncSequence</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://hws.dev/quotes.txt&quot;</span>)<span class="operator">!</span></span><br><span class="line">  <span class="keyword">let</span> anonymousQuotes <span class="operator">=</span> url.lines.filter &#123; <span class="variable">$0</span>.contains(<span class="string">&quot;Anonymous&quot;</span>) &#125;</span><br><span class="line">  <span class="keyword">let</span> topAnonymousQuotes <span class="operator">=</span> anonymousQuotes.prefix(<span class="number">5</span>)</span><br><span class="line">  <span class="keyword">let</span> shoutingTopAnonymousQuotes <span class="operator">=</span> topAnonymousQuotes.map(\.localizedUppercase)</span><br><span class="line">  <span class="keyword">return</span> shoutingTopAnonymousQuotes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> getQuotes()</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">try</span> <span class="keyword">await</span> quote <span class="keyword">in</span> result &#123;</span><br><span class="line">    <span class="built_in">print</span>(quote)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Error fetching quotes&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，所有转换都创建了新的异步序列，因此我们不需要将它们与 <code>await</code> 一起使用，但许多转换也会生成单个值。这些必须使用 <code>await</code> 才能挂起，直到返回序列的所有部分，并且如果序列抛出，可能还需要使用 <code>try</code>。例如， <code>allSatisfy()</code>，检查异步序列中的所有元素是否都通过您选择的谓词。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">checkQuotes</span>() <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://hws.dev/quotes.txt&quot;</span>)<span class="operator">!</span></span><br><span class="line">  <span class="keyword">let</span> noShortQuotes <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> url.lines.allSatisfy &#123; <span class="variable">$0</span>.count <span class="operator">&gt;</span> <span class="number">30</span> &#125;</span><br><span class="line">  <span class="built_in">print</span>(noShortQuotes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try?</span> <span class="keyword">await</span> checkQuotes()</span><br></pre></td></tr></table></figure>
<p>其他类似的函数也是如此，例如 <code>min()</code> 、 <code>max()</code> 和 <code>reduce()</code>。</p>
<h3 id="创建自定义异步序列"><a class="markdownIt-Anchor" href="#创建自定义异步序列"></a> 创建自定义异步序列</h3>
<p>创建 <code>AsyncSequence</code>：</p>
<ul>
<li>需要遵守 <code>AsyncSequence</code> 和 <code>AsyncIteratorProtocol</code> 协议</li>
<li>迭代器的 <code>next()</code> 方法必须标记为 <code>async</code></li>
<li>需要创建一个 <code>makeAsyncIterator()</code> 方法</li>
</ul>
<p>下面是一个简单的每次调用 next() 时数字都会加倍的异步序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DoubleGenerator</span>: <span class="title class_">AsyncSequence</span>, <span class="title class_">AsyncIteratorProtocol</span> &#123;</span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">Element</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> current <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">next</span>() <span class="keyword">async</span> -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">defer</span> &#123; current <span class="operator">&amp;*=</span> <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> current <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> current</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">makeAsyncIterator</span>() -&gt; <span class="type">DoubleGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sequence <span class="operator">=</span> <span class="type">DoubleGenerator</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> number <span class="keyword">in</span> sequence &#123;</span><br><span class="line">  <span class="built_in">print</span>(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另：在 Swift 编程语言中，<code>&amp;*=</code> 是一个复合赋值运算符，用于执行带符号整数的溢出乘法操作。该运算符结合了溢出乘法运算符 <code>&amp;*</code> 和赋值运算符 <code>=</code>。它可以确保在计算结果超出变量存储范围时，不会抛出溢出错误，而是保留溢出的结果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a: <span class="type">Int</span> <span class="operator">=</span> <span class="type">Int</span>.max</span><br><span class="line">a <span class="operator">&amp;*=</span> <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">// 输出为 -2</span></span><br></pre></td></tr></table></figure>
<h3 id="将-asyncsequence-转换为-sequence"><a class="markdownIt-Anchor" href="#将-asyncsequence-转换为-sequence"></a> 将 AsyncSequence 转换为 Sequence</h3>
<p>最简单的方法是在序列上调用 <code>reduce(into:)</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">AsyncSequence</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">collect</span>() <span class="keyword">async</span> <span class="keyword">rethrows</span> -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">await</span> reduce(into: [<span class="type">Element</span>]()) &#123; <span class="variable">$0</span>.append(<span class="variable">$1</span>) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="task"><a class="markdownIt-Anchor" href="#task"></a> Task</h2>
<p>在 Swift 中使用 <code>async/await</code> 允许我们编写易于阅读和理解的异步代码，但它本身仍然会按顺序执行。为了创建实际的并发性（提供同时运行多个工作的能力），Swift 为我们提供了两种特定的类型： <code>Task</code> 和 <code>TaskGroup</code>。</p>
<p>如果只是开始一两个独立的工作，那么 <code>Task</code> 是正确的选择。如果想将一项作业拆分为多个并发操作，那么 <code>TaskGroup</code> 更适合。</p>
<p><code>Task</code> 和 <code>TaskGroup</code> 的优先级从高到低依次是 <code>high</code>、<code>medium</code>、<code>low</code>、<code>background</code>。与 DispatchQueue 的 quality-of-service 相比，<code>.high</code> 等同于 <code>.userInitiated</code>，<code>.low</code> 等同于 <code>.utility</code>。</p>
<h3 id="task-的创建和运行"><a class="markdownIt-Anchor" href="#task-的创建和运行"></a> Task 的创建和运行</h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NewsItem</span>: <span class="title class_">Decodable</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> url: <span class="type">URL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HighScore</span>: <span class="title class_">Decodable</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> score: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">fetchUpdates</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> newsTask <span class="operator">=</span> <span class="type">Task</span> &#123; () -&gt; [<span class="type">NewsItem</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://hws.dev/headlines.json&quot;</span>)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">let</span> (data, <span class="keyword">_</span>) <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">URLSession</span>.shared.data(from: url)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode([<span class="type">NewsItem</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> highScoreTask <span class="operator">=</span> <span class="type">Task</span> &#123; () -&gt; [<span class="type">HighScore</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://hws.dev/scores.json&quot;</span>)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">let</span> (data, <span class="keyword">_</span>) <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">URLSession</span>.shared.data(from: url)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode([<span class="type">HighScore</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> news <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> newsTask.value</span><br><span class="line">    <span class="keyword">let</span> highScores <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> highScoreTask.value</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Latest news loaded with <span class="subst">\(news.count)</span> items.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> topScore <span class="operator">=</span> highScores.first &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(topScore.name)</span> has the highest score with <span class="subst">\(topScore.score)</span>, out of <span class="subst">\(highScores.count)</span> total results.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;There was an error loading user data.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> fetchUpdates()</span><br></pre></td></tr></table></figure>
<ul>
<li>Taxks 并不总是需要返回值，这里的返回值是 <code>[NewsItem]</code>；</li>
<li>一旦创建了任务，它就会开始运行；</li>
<li>如果要读取任务的返回值，则需要使用 <code>await</code> 访问其 <code>value</code> 属性。</li>
</ul>
<h3 id="detached-task"><a class="markdownIt-Anchor" href="#detached-task"></a> Detached Task</h3>
<p><code>Task</code> 会继承并运行在调用它的当前任务的执行环境和优先级下。它通常用于创建一个附属于当前上下文的任务，这样可以共享当前上下文的一些特性，例如：Actor 的隔离状态或结构化并发的范围。</p>
<p><code>Task.detached</code> 会创建一个与当前上下文分离的独立任务。它不会继承创建它的上下文的优先级和任务状态，而是作为一个全新的任务来执行。通常在需要完全独立的并发执行时使用 <code>Task.detached</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ViewModel</span>: <span class="title class_">ObservableObject</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">  <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">ViewModel</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Authenticate&quot;</span>, action: doWork)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">doWork</span>() &#123;</span><br><span class="line">    <span class="type">Task</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10_000</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;In Task 1: <span class="subst">\(i)</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Task</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10_000</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;In Task 2: <span class="subst">\(i)</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中的两个 <code>Task</code>，但它们也是按顺序执行的，因为 <code>@StateObject</code> 视图模型将整个视图强制到 <code>main actor</code> 上，这意味着它一次只能做一件事。这时，将 <code>Task</code> 更改为 <code>Task.detached</code>，这两个任务就可以同时运行。</p>
<h3 id="从任务中获取结果"><a class="markdownIt-Anchor" href="#从任务中获取结果"></a> 从任务中获取结果</h3>
<p>如果你想直接读取一个任务（Task）的返回值，应该使用 <code>await</code> 来读取其值，或者如果它包含抛出操作（throwing operation），则使用 <code>try await</code>。然而，所有任务也都有一个 <code>result</code> 属性，该属性返回一个 Swift 的 <code>Result</code> 结构实例，泛型化为任务返回的类型以及它是否可能包含错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">LoadError</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> fetchFailed, decodeFailed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">fetchQuotes</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> downloadTask <span class="operator">=</span> <span class="type">Task</span> &#123; () -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://hws.dev/quotes.txt&quot;</span>)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">let</span> data: <span class="type">Data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      (data, <span class="keyword">_</span>) <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">URLSession</span>.shared.data(from: url)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">LoadError</span>.fetchFailed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> string <span class="operator">=</span> <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">      <span class="keyword">return</span> string</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">LoadError</span>.decodeFailed</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> downloadTask.result</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> string <span class="operator">=</span> <span class="keyword">try</span> result.get()</span><br><span class="line">    <span class="built_in">print</span>(string)</span><br><span class="line">  &#125; <span class="keyword">catch</span> <span class="type">LoadError</span>.fetchFailed &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to fetch the quotes.&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> <span class="type">LoadError</span>.decodeFailed &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to convert quotes to text.&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unknown error.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> fetchQuotes()</span><br></pre></td></tr></table></figure>
<h3 id="任务优先级"><a class="markdownIt-Anchor" href="#任务优先级"></a> 任务优先级</h3>
<p>创建一个具有优先级的任务：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span>(priority: .high) &#123; () -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="comment">// More code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然您可以在创建任务时直接为其分配优先级，但如果不指定优先级，Swift 将遵循三个规则自动确定优先级：</p>
<ol>
<li>如果该任务是从另一个任务创建的，则子任务将继承父任务的优先级。</li>
<li>如果新任务是直接从主线程而不是任务创建的，则会自动为其分配最高优先级 <code>.userInitiated</code> 。</li>
<li>如果新任务不是由另一个任务或主线程创建的，Swift 将尝试查询线程的优先级或为其赋予 <code>nil</code> 优先级。</li>
</ol>
<p>任何任务都可以使用 <code>Task.currentPriority</code> 查询其当前优先级。</p>
<h3 id="优先级升级"><a class="markdownIt-Anchor" href="#优先级升级"></a> 优先级升级</h3>
<p>每个任务都可以创建为具有特定的优先级，也可以从其他地方继承优先级。但在两种特定情况下，Swift 会提高任务的优先级，以便能够更快地完成。</p>
<ol>
<li>如果较高优先级任务 A 开始等待较低优先级任务 B 的结果，则任务 B 的优先级将提升到与任务 A 相同的优先级。</li>
<li>如果较低优先级的任务 A 已开始在某个 Actor 上运行，并且较高优先级的任务 B 已在该 Actor 上排队，则任务 A 的优先级将提升以匹配任务 B。</li>
</ol>
<p>注意，第 2 种情况下，低优先级任务，其优先级会升级，但不会改变其 <code>currentPriority</code> 的值。</p>
<h3 id="取消任务"><a class="markdownIt-Anchor" href="#取消任务"></a> 取消任务</h3>
<p>虽然我们可以告诉任务停止工作，但任务本身可以完全忽略该指令并根据需要继续执行。</p>
<ol>
<li>可以通过调用任务的 <code>cancel()</code> 方法显式取消任务。</li>
<li>可以检查 <code>Task.isCancelled</code> 来确定任务是否已被取消。</li>
<li>可以调用 <code>Task.checkCancellation()</code> 方法，如果任务已取消，该方法将抛出 <code>CancellationError</code>，否则不做任何操作。</li>
<li>Foundation 的某些部分会自动检查任务取消情况，即使没有你的输入也会抛出它们自己的取消错误</li>
<li>如果你使用 <code>Task.sleep()</code> 来等待一段时间，取消你的任务将自动终止等待并抛出 <code>CancellationError</code>。</li>
<li>如果任务是一个组的一部分，并且组的任何部分抛出错误，其他任务将被取消并等待。</li>
<li>如果你使用 SwiftUI 的 <code>task()</code> 修饰符启动了一个任务，该任务将在视图消失时自动取消。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getAverageTemperature</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> fetchTask <span class="operator">=</span> <span class="type">Task</span> &#123; () -&gt; <span class="type">Double</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://hws.dev/readings.json&quot;</span>)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">let</span> (data, <span class="keyword">_</span>) <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">URLSession</span>.shared.data(from: url)</span><br><span class="line">    <span class="keyword">try</span> <span class="type">Task</span>.checkCancellation()</span><br><span class="line">    <span class="keyword">let</span> readings <span class="operator">=</span> <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode([<span class="type">Double</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line">    <span class="keyword">let</span> sum <span class="operator">=</span> readings.reduce(<span class="number">0</span>, <span class="operator">+</span>)</span><br><span class="line">    <span class="keyword">return</span> sum <span class="operator">/</span> <span class="type">Double</span>(readings.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> fetchTask.value</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Average temperature: <span class="subst">\(result)</span>&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Failed to get data.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> getAverageTemperature()</span><br></pre></td></tr></table></figure>
<p><code>URLSession.shared.data(from:)</code> 存在隐式取消，其调用将在继续之前检查其任务是否仍处于活动状态。如果任务已被取消，<code>data(from:)</code> 将自动抛出 <code>URLError</code> 并且任务的其余部分将不会执行。<br />
这里使用 <code>Task.checkCancellation()</code>，以在网络请求后显式检查取消。</p>
<p>下面的代码在任务创建后立即取消任务，并返回默认值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getAverageTemperature</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> fetchTask <span class="operator">=</span> <span class="type">Task</span> &#123; () -&gt; <span class="type">Double</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://hws.dev/readings.json&quot;</span>)<span class="operator">!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> (data, <span class="keyword">_</span>) <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">URLSession</span>.shared.data(from: url)</span><br><span class="line">      <span class="keyword">if</span> <span class="type">Task</span>.isCancelled &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> readings <span class="operator">=</span> <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode([<span class="type">Double</span>].<span class="keyword">self</span>, from: data)</span><br><span class="line">      <span class="keyword">let</span> sum <span class="operator">=</span> readings.reduce(<span class="number">0</span>, <span class="operator">+</span>)</span><br><span class="line">      <span class="keyword">return</span> sum <span class="operator">/</span> <span class="type">Double</span>(readings.count)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fetchTask.cancel()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> fetchTask.value</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Average temperature: <span class="subst">\(result)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> getAverageTemperature()</span><br></pre></td></tr></table></figure>
<p>现在我们有一个通过 <code>data(from:)</code> 调用的隐式取消点，以及一个通过 <code>Task.isCancelled</code> 检查的显式取消点。如果其中任何一个被触发，任务将返回 0 而不是抛出错误。</p>
<h3 id="休眠任务"><a class="markdownIt-Anchor" href="#休眠任务"></a> 休眠任务</h3>
<p>使当前任务休眠至少 3 秒：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> <span class="keyword">await</span> <span class="type">Task</span>.sleep(nanoseconds: <span class="number">3_000_000_000</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>需要使用 <code>await</code> 调用 <code>Task.sleep()</code>；</li>
<li>需要使用 <code>try</code> ，因为 <code>Task.sleep()</code> 会自动检查取消，如果任务被取消，将会抛出一个 <code>CancellationError</code> 错误。</li>
</ul>
<p>注意：调用 <code>Task.sleep()</code> 将使当前任务至少休眠您要求的时间，而不是您要求的确切时间。因为当睡眠结束时系统可能正忙于做其他工作。</p>
<p>另外，与使线程休眠不同，<code>Task.sleep()</code> 不会阻塞底层线程，因此在需要时它可以从其他地方获取工作。</p>
<h3 id="主动暂停任务"><a class="markdownIt-Anchor" href="#主动暂停任务"></a> 主动暂停任务</h3>
<p>可以调用 <code>Task.yield()</code> 来自动挂起当前任务。但调用 <code>yield()</code> 并不总是意味着任务会停止运行：如果它的优先级高于其他等待的任务，你的任务完全有可能立即恢复工作。将其视为一种指导——我们只是给 Swift 一个临时执行其他任务的机会，而不是强制它这样做。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">factors</span>(<span class="params">for</span> <span class="params">number</span>: <span class="type">Int</span>) <span class="keyword">async</span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> result <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> check <span class="keyword">in</span> <span class="number">1</span> <span class="operator">...</span> number &#123;</span><br><span class="line">    <span class="keyword">if</span> number.isMultiple(of: check) &#123;</span><br><span class="line">      result.append(check)</span><br><span class="line">      <span class="keyword">await</span> <span class="type">Task</span>.yield()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> factors <span class="operator">=</span> <span class="keyword">await</span> factors(for: <span class="number">120</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Found <span class="subst">\(factors.count)</span> factors for 120.&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="task-group"><a class="markdownIt-Anchor" href="#task-group"></a> Task Group</h2>
<h3 id="创建任务组并向其中添加任务"><a class="markdownIt-Anchor" href="#创建任务组并向其中添加任务"></a> 创建任务组并向其中添加任务</h3>
<p>并不是直接创建 <code>TaskGroup</code> 实例，而是通过调用 <code>withTaskGroup(of:)</code> 函数，并告诉它任务组将返回的数据类型。</p>
<p>下面是一个简单的示例，它返回 5 个常量字符串，将它们添加到一个数组中，然后将该数组连接到一个字符串中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printMessage</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> string <span class="operator">=</span> <span class="keyword">await</span> withTaskGroup(of: <span class="type">String</span>.<span class="keyword">self</span>) &#123; group -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    group.addTask &#123; <span class="string">&quot;Hello&quot;</span> &#125;</span><br><span class="line">    group.addTask &#123; <span class="string">&quot;From&quot;</span> &#125;</span><br><span class="line">    group.addTask &#123; <span class="string">&quot;A&quot;</span> &#125;</span><br><span class="line">    group.addTask &#123; <span class="string">&quot;Task&quot;</span> &#125;</span><br><span class="line">    group.addTask &#123; <span class="string">&quot;Group&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> collected <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> value <span class="keyword">in</span> group &#123;</span><br><span class="line">      collected.append(value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> collected.joined(separator: <span class="string">&quot; &quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> printMessage()</span><br></pre></td></tr></table></figure>
<ol>
<li>我们必须指定任务组将返回的数据的确切类型，在我们的例子中是 <code>String.self</code> ，以便每个子任务都可以返回一个字符串。</li>
<li>我们需要使用 <code>group -&gt; String in</code> 准确指定组的返回值。</li>
<li>对于要添加到组中的每个任务，可以调用 <code>addTask()</code>。</li>
<li>任务组符合 <code>AsyncSequence</code> ，因此我们可以使用 <code>for await</code> 或重复调用 <code>group.next()</code> 从其子级读取所有值。</li>
<li>因为整个任务组是异步执行的，所以我们必须使用 <code>await</code> 来调用它。</li>
<li>注意返回的结果是按完成顺序而不是创建的顺序。</li>
<li>使用 <code>withTaskGroup()</code> 创建的任务不能抛出错误。如果您希望它们能够抛出向上冒泡的错误（即在任务组之外处理的错误），您应该使用 <code>withThrowingTaskGroup()</code> 来代替。</li>
</ol>
<p>无论您使用的是抛出任务还是非抛出任务，组中的所有任务都必须在组返回之前完成。您在这里有三个选择：</p>
<ol>
<li>等待组中的所有任务完成。</li>
<li>调用 <code>waitForAll()</code> 将自动等待您未明确等待的任务，并丢弃它们返回的任何结果。</li>
<li>如果您没有显式等待任何子任务，它们将被隐式等待 - Swift 无论如何都会等待它们，即使您没有使用它们的返回值。</li>
</ol>
<h3 id="取消任务组"><a class="markdownIt-Anchor" href="#取消任务组"></a> 取消任务组</h3>
<p>Swift 的任务组可以通过以下三种方式之一取消：</p>
<ol>
<li>如果任务组的父任务被取消。</li>
<li>如果您在组上明确调用 <code>cancelAll()</code>。</li>
<li>如果您的子任务之一引发未捕获的错误，则所有剩余任务将被隐式取消。</li>
</ol>
<p>首先，调用 <code>cancelAll()</code> 将取消所有剩余的任务。与独立任务一样，取消任务组是合作性的：你的子任务可以使用 <code>Task.isCancelled</code> 或 <code>Task.checkCancellation()</code> 来检查是否被取消，但如果它们愿意，也可以完全忽略取消操作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printMessage</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> withThrowingTaskGroup(of: <span class="type">String</span>.<span class="keyword">self</span>) &#123; group -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    group.addTask &#123;</span><br><span class="line">      <span class="string">&quot;Testing&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    group.addTask &#123;</span><br><span class="line">      <span class="string">&quot;Group&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    group.addTask &#123;</span><br><span class="line">      <span class="string">&quot;Cancellation&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    group.cancelAll()</span><br><span class="line">    <span class="keyword">var</span> collected <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> <span class="keyword">try</span> <span class="keyword">await</span> value <span class="keyword">in</span> group &#123;</span><br><span class="line">        collected.append(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> collected.joined(separator: <span class="string">&quot; &quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> printMessage()</span><br></pre></td></tr></table></figure>
<p>上面的代码，在创建所有三个任务后立即调用 <code>cancelAll()</code>，但是当代码运行时，您仍然会看到所有三个字符串都打印出来。因为取消任务组是合作性的，所以除非你添加的任务隐式或显式地检查取消状态，否则单独调用 <code>cancelAll()</code> 并不会有太大作用。</p>
<p>尝试将第一个 <code>addTask()</code> 调用替换为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">group.addTask &#123;</span><br><span class="line">  <span class="keyword">try</span> <span class="type">Task</span>.checkCancellation()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Testing&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发现其结果还是不确定的，这是因为：Swift 将立即启动所有三个任务，它们可能全部并行运行，尽管我们立即调用 <code>cancelAll()</code>，但某些任务可能已经开始运行。</p>
<p>请记住，调用 <code>cancelAll()</code> 只会取消剩余的任务，这意味着它不会撤销已经完成的工作。即便如此，取消也是合作性的，因此你需要确保你添加到组中的任务会检查取消状态。</p>
<h3 id="如何处理任务组中的不同结果类型"><a class="markdownIt-Anchor" href="#如何处理任务组中的不同结果类型"></a> 如何处理任务组中的不同结果类型</h3>
<p>Swift 任务组中的每个任务必须返回与组中所有其他任务相同类型的数据，如果需要一个任务组来处理多种不同类型的数据，如果可以的话，您应该考虑使用 <code>async let</code> 来实现并发。</p>
<p>还有一个解决方案：创建一个具有关联值的枚举，该值包装您想要返回的基础数据。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">FetchResult</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> username(<span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> favorites(<span class="type">Set</span>&lt;<span class="type">Int</span>&gt;)</span><br><span class="line">  <span class="keyword">case</span> messages([<span class="type">Message</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">loadUser</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> user <span class="operator">=</span> <span class="keyword">await</span> withThrowingTaskGroup(of: <span class="type">FetchResult</span>.<span class="keyword">self</span>) &#123; <span class="keyword">_</span> -&gt; <span class="type">User</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// more code here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> loadUser()</span><br></pre></td></tr></table></figure>
<h2 id="swiftui-中的-task-修饰符"><a class="markdownIt-Anchor" href="#swiftui-中的-task-修饰符"></a> SwiftUI 中的 task() 修饰符</h2>
<p>SwiftUI 提供了一个 <code>task()</code> 修饰符，一旦视图出现，它就会启动一个新的分离任务，并在视图消失时自动取消该任务。</p>
<ol>
<li>最简单的也是常用的，在 <code>task()</code> 中加载视图初始数据。</li>
<li>更高级的 <code>task()</code> 用法是附加某种 <code>Equatable</code> 的标识值 <code>.task(id:)</code> ——当该值发生变化时，SwiftUI 会自动取消之前的任务，并使用新值创建一个新任务。</li>
<li><code>task()</code> 的一个特别有趣的用例是与连续生成值的 <code>AsyncSequence</code> 集合一起使用。</li>
</ol>
<h2 id="actors"><a class="markdownIt-Anchor" href="#actors"></a> Actors</h2>
<p>Swift 的 actors 在概念上类似于类，但在并发环境中使用是安全的。这种安全性是因为 Swift 自动确保没有两段代码试图同时访问 actor 的数据——这是由编译器强制实现的，而不是要求开发人员编写使用锁等系统的样板代码。</p>
<ul>
<li>Actors 是使用 <code>actor</code> 关键字创建的。</li>
<li>Actors 是引用类型。</li>
<li>Actors 具有许多与类相同的特性：你可以为它们定义属性、方法（异步或其他方法）、初始化器和下标，它们可以遵循协议，并且可以是泛型。</li>
<li>Actors 不支持继承，因此它们不能有便利初始化器，也不支持 <code>final</code> 或 <code>override</code>。</li>
<li>所有 actors 会自动遵循 <code>Actor</code> 协议，而其他类型不能使用该协议。这使你可以编写仅限于与 actor 一起工作的代码。</li>
</ul>
<p>除此之外，actor 还有一个核心行为：如果你尝试读取 actor 的变量属性或调用其方法，并且是在 actor 外部进行的，那么你必须使用 <code>await</code> 以异步方式进行。</p>
<p>下面是一个简单的示例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actor</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> score <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">printScore</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My score is <span class="subst">\(score)</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">copyScore</span>(<span class="params">from</span> <span class="params">other</span>: <span class="type">User</span>) <span class="keyword">async</span> &#123;</span><br><span class="line">    score <span class="operator">=</span> <span class="keyword">await</span> other.score</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> actor1 <span class="operator">=</span> <span class="type">User</span>()</span><br><span class="line"><span class="keyword">let</span> actor2 <span class="operator">=</span> <span class="type">User</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">print</span>(actor1.score)</span><br><span class="line"><span class="keyword">await</span> actor1.copyScore(from: actor2)</span><br></pre></td></tr></table></figure>
<p>从 actor 外部写入属性是不允许的，无论是否使用 <code>await</code>。</p>
<h3 id="函数参数隔离"><a class="markdownIt-Anchor" href="#函数参数隔离"></a> 函数参数隔离</h3>
<p>属于 actor 的任何属性和方法都是隔离到该 actor 的，但如果需要，你可以让外部函数也隔离到某个 actor。这样，该函数就可以像在该 actor 内部一样访问 actor 隔离的状态，而无需使用 <code>await</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actor</span> <span class="title class_">DataStore</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> username <span class="operator">=</span> <span class="string">&quot;Anonymous&quot;</span></span><br><span class="line">  <span class="keyword">var</span> friends <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line">  <span class="keyword">var</span> highScores <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line">  <span class="keyword">var</span> favorites <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="comment">// load data here</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">save</span>() &#123;</span><br><span class="line">    <span class="comment">// save data here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">debugLog</span>(<span class="params">dataStore</span>: <span class="keyword">isolated</span> <span class="type">DataStore</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Username: <span class="subst">\(dataStore.username)</span>&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Friends: <span class="subst">\(dataStore.friends)</span>&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;High scores: <span class="subst">\(dataStore.highScores)</span>&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Favorites: <span class="subst">\(dataStore.favorites)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data <span class="operator">=</span> <span class="type">DataStore</span>()</span><br><span class="line"><span class="keyword">await</span> debugLog(dataStore: data)</span><br></pre></td></tr></table></figure>
<p>函数签名中添加的 <code>isolated</code> 关键字，它允许直接访问 <code>DataStore</code> 的属性而不需要使用 <code>await</code>，整个函数必须在该 actor 上运行，因此需要使用 <code>await</code> 调用 <code>debugLog(dataStore:)</code>。</p>
<h3 id="部分隔离"><a class="markdownIt-Anchor" href="#部分隔离"></a> 部分隔离</h3>
<p>默认情况下，Actor 内部的所有方法和可变属性都与该 Actor 隔离，可以使用 <code>nonisolated</code> 关键字将某些方法排除在外。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CryptoKit</span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">actor</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> username: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> password: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> isOnline <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="params">username</span>: <span class="type">String</span>, <span class="params">password</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.username <span class="operator">=</span> username</span><br><span class="line">    <span class="keyword">self</span>.password <span class="operator">=</span> password</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">nonisolated</span> <span class="keyword">func</span> <span class="title function_">passwordHash</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> passwordData <span class="operator">=</span> <span class="type">Data</span>(password.utf8)</span><br><span class="line">    <span class="keyword">let</span> hash <span class="operator">=</span> <span class="type">SHA256</span>.hash(data: passwordData)</span><br><span class="line">    <span class="keyword">return</span> hash.compactMap &#123; <span class="type">String</span>(format: <span class="string">&quot;%02x&quot;</span>, <span class="variable">$0</span>) &#125;.joined()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user <span class="operator">=</span> <span class="type">User</span>(username: <span class="string">&quot;twostraws&quot;</span>, password: <span class="string">&quot;s3kr1t&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(user.passwordHash())</span><br></pre></td></tr></table></figure>
<ul>
<li>将 <code>passwordHash()</code> 标记为 <code>nonisolated</code> 意味着我们可以在外部调用它，而无需使用 <code>await</code>。</li>
<li>还可以将 <code>nonisolated</code> 与计算属性一起使用。</li>
<li>非隔离属性和方法只能访问其他非隔离属性和方法。</li>
</ul>
<h3 id="使用-mainactor-在主队列上运行代码"><a class="markdownIt-Anchor" href="#使用-mainactor-在主队列上运行代码"></a> 使用 @MainActor 在主队列上运行代码</h3>
<p><code>@MainActor</code> 是一个全局 actor，它使用主队列来执行其工作。</p>
<p>例如，我们可以创建一个具有两个 <code>@Published</code> 属性的可观察对象，并且因为它们都会更新 UI，所以我们将用 <code>@MainActor</code> 标记整个类，以确保这些 UI 更新始终发生在 main actor：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainActor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountViewModel</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">  <span class="meta">@Published</span> <span class="keyword">var</span> username <span class="operator">=</span> <span class="string">&quot;Anonymous&quot;</span></span><br><span class="line">  <span class="meta">@Published</span> <span class="keyword">var</span> isAuthenticated <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，不需要显式地将 <code>@MainActor</code> 添加到可观察对象，因为 SwiftUI 视图的 <code>body</code> 属性始终在主 actor 上运行。如果您需要某些方法或计算属性来选择不在主 actor 上运行，可以使用 <code>nonisolated</code>。</p>
<p>更广泛地说，任何包含 <code>@MainActor</code> 对象作为属性的类型也会隐式地被认为是 <code>@MainActor</code>，这是通过全局 actor 推断实现的。</p>
<p><code>@MainActor</code> 会自动强制方法或整个类型在主 actor 上运行，大多数情况下无需我们做任何额外的工作。以前我们需要手动完成这项工作，记得在每个需要的地方使用诸如 <code>DispatchQueue.main.async()</code> 之类的代码，但现在编译器会自动为我们处理这一切。</p>
<p><code>MainActor.run()</code> 方法是 Swift 中用于在主线程上执行代码的一种便捷方式。使用这个方法，你可以确保指定的代码块在主线程上运行，从而避免手动切换线程的麻烦。</p>
<ol>
<li>简化线程切换：<code>MainActor.run()</code> 简化了将代码调度到主线程的过程，不需要手动调用 <code>DispatchQueue.main.async()</code>。</li>
<li>支持异步代码：<code>MainActor.run()</code> 支持异步代码，你可以在其内部使用 <code>await</code>。</li>
<li>保证主线程执行：使用 <code>MainActor.run()</code> 可以确保代码在主线程上执行，适用于需要在主线程上运行的 UI 更新等任务。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">couldBeAnywhere</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> <span class="type">MainActor</span>.run &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is on the main actor.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> couldBeAnywhere()</span><br></pre></td></tr></table></figure>
<p>也可以将任务的结束标记为 <code>@MainActor</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">couldBeAnywhere</span>() &#123;</span><br><span class="line">  <span class="type">Task</span> &#123; <span class="meta">@MainActor</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is on the main actor.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">couldBeAnywhere()</span><br></pre></td></tr></table></figure>
<p><code>MainActor.run()</code> 代码将立即执行 - 它不会像 <code>DispatchQueue.main.async()</code> 那样等到下一个运行循环。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainActor</span> <span class="keyword">class</span> <span class="title class_">ViewModel</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">runTest</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="type">MainActor</span>.run &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="type">Task</span> &#123; <span class="meta">@MainActor</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MainActor.run()</code> 的调用将在调用 <code>runTest()</code> 时立即运行。但是，内部的 <code>Task</code> 不会立即运行，因此代码将打印 1, 2, 4, 5, 3。</p>
<h3 id="全局-actor-推断的工作原理"><a class="markdownIt-Anchor" href="#全局-actor-推断的工作原理"></a> 全局 actor 推断的工作原理</h3>
<ol>
<li>
<p>如果一个类被标记为 <code>@MainActor</code> ，那么它的所有子类也自动被标记为 <code>@MainActor</code>。</p>
</li>
<li>
<p>如果类中的方法被标记为 <code>@MainActor</code> ，则该方法的任何重写也会自动标记为 <code>@MainActor</code>。</p>
</li>
<li>
<p>任何使用 <code>@MainActor</code> 作为其包装值的属性包装器的结构或类将自动为 <code>@MainActor</code>。</p>
</li>
<li>
<p>如果一个协议声明了一个方法是 <code>@MainActor</code>，那么任何遵循该协议的类型都会自动将该方法视为 <code>@MainActor</code>，除非你将协议的遵循与方法的实现分开。</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A protocol with a single `@MainActor` method.</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">DataStoring</span> &#123;</span><br><span class="line">  <span class="meta">@MainActor</span> <span class="keyword">func</span> <span class="title function_">save</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A struct that does not conform to the protocol.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataStore1</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When we make it conform and add save() at the same time, our method is implicitly @MainActor.</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">DataStore1</span>: <span class="title class_">DataStoring</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">save</span>() &#123; &#125; <span class="comment">// This is automatically @MainActor.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A struct that conforms to the protocol.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataStore2</span>: <span class="title class_">DataStoring</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we later add the save() method, it will *not* be implicitly @MainActor so we need to mark it as such ourselves.</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">DataStore2</span> &#123;</span><br><span class="line">  <span class="meta">@MainActor</span> <span class="keyword">func</span> <span class="title function_">save</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果整个协议标记为 <code>@MainActor</code>，那么任何遵循该协议的类型在不显式分离协议遵循与主类型声明的情况下，也会自动成为 <code>@MainActor</code>；而如果你将协议的遵循与主类型声明分离开来，那么只有方法会被标记为 <code>@MainActor</code>。</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A protocol marked as @MainActor.</span></span><br><span class="line"><span class="meta">@MainActor</span> <span class="keyword">protocol</span> <span class="title class_">DataStoring</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">save</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A struct that conforms to DataStoring as part of its primary type definition.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataStore1</span>: <span class="title class_">DataStoring</span> &#123; <span class="comment">// This struct is automatically @MainActor.</span></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">save</span>() &#123; &#125; <span class="comment">// This method is automatically @MainActor.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Another struct that conforms to DataStoring as part of its primary type definition.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataStore2</span>: <span class="title class_">DataStoring</span> &#123; &#125; <span class="comment">// This struct is automatically @MainActor.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The method is provided in an extension, but it&#x27;s the same as if it were in the primary type definition.</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">DataStore2</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">save</span>() &#123; &#125; <span class="comment">// This method is automatically @MainActor.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A third struct that does *not* conform to DataStoring in its primary type definition.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataStore3</span> &#123; &#125; <span class="comment">// This struct is not @MainActor.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The conformance is added as an extension</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">DataStore3</span>: <span class="title class_">DataStoring</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">save</span>() &#123; &#125; <span class="comment">// This method is automatically @MainActor.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="actor-跳跃"><a class="markdownIt-Anchor" href="#actor-跳跃"></a> actor 跳跃</h3>
<p>当一个线程暂停一个 actor 上的工作，转而开始在另一个 actor 上工作时，我们称之为 actor 跳跃（actor hopping）。这种情况会在一个 actor 调用另一个 actor 时发生。Actor hopping 的发生可以由编译器自动管理，确保并发操作的线程安全性和顺序执行，而无需开发人员显式管理线程切换。</p>
<p>但还是有一些注意事项：</p>
<ol>
<li>性能影响：Actor 跳跃可能会引入额外的性能开销，因为线程需要在不同的 actor 之间切换。尽管 Swift 的并发模型尽可能地优化了这些切换过程，但频繁的 actor 跳跃仍可能影响到应用程序的响应性能。</li>
<li>线程安全：由于 Swift 的 Actor 模型确保了同一时间只有一个 actor 的代码可以执行，因此 actor 跳跃可以保证并发访问的线程安全性。然而，开发人员仍需注意避免可能导致竞态条件或数据不一致的操作。</li>
<li>异步操作：在执行 actor 跳跃时，可能涉及异步操作和等待。特别是当一个 actor 调用另一个 actor 的异步方法时，可能需要使用 await 来等待结果的返回，以确保异步操作的正确顺序。</li>
<li>代码设计：合理的代码设计可以减少 actor 跳跃的频率。尽量将相关的操作和数据封装在同一个 actor 内部，减少不同 actor 之间的交互，可以降低 actor 跳跃的发生频率，提升性能和可维护性。</li>
</ol>
<p>下面是一个简单的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actor</span> <span class="title class_">NumberGenerator</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> lastNumber <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">getNext</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> &#123; lastNumber <span class="operator">+=</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> lastNumber</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MainActor</span> <span class="keyword">func</span> <span class="title function_">run</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span> <span class="operator">...</span> <span class="number">100</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> nextNumber <span class="operator">=</span> <span class="keyword">await</span> getNext()</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Loading <span class="subst">\(nextNumber)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator <span class="operator">=</span> <span class="type">NumberGenerator</span>()</span><br><span class="line"><span class="keyword">await</span> generator.run()</span><br></pre></td></tr></table></figure>
<p>在这段代码中，<code>run()</code> 方法必须在主 actor 上执行，因为它带有 <code>@MainActor</code> 属性，然而 <code>getNext()</code> 方法将在协作池（cooperative pool）的某个地方运行，这意味着 Swift 需要在循环内频繁地在主 actor 和协作池之间进行上下文切换。</p>
<h3 id="actors-classes-and-structs-之间的区别"><a class="markdownIt-Anchor" href="#actors-classes-and-structs-之间的区别"></a> actors, classes, and structs 之间的区别</h3>
<p>Actors:</p>
<ul>
<li>是引用类型，适合用于共享可变状态。</li>
<li>可以拥有属性、方法、初始化器和下标。</li>
<li>不支持继承。</li>
<li>自动遵循 Actor 协议。</li>
<li>自动遵循 AnyObject 协议，因此可以在不添加显式 id 属性的情况下遵循 Identifiable 协议。</li>
<li>可以有析构器。</li>
<li>不能直接从外部访问其公共属性和方法；必须使用 await。</li>
<li>只能同时执行一个方法，无论它们如何被访问。</li>
</ul>
<p>Classes：</p>
<ul>
<li>是引用类型，适合用于共享可变状态。</li>
<li>可以拥有属性、方法、初始化器和下标。</li>
<li>支持继承。</li>
<li>不能遵循 Actor 协议。</li>
<li>自动遵循 AnyObject 协议，因此可以在不添加显式 id 属性的情况下遵循 Identifiable 协议。</li>
<li>可以有析构器。</li>
<li>可以直接从外部访问其公共属性和方法。</li>
<li>可能同时执行多个方法。</li>
</ul>
<p>Structs：</p>
<ul>
<li>是值类型，会被复制而不是共享。</li>
<li>可以拥有属性、方法、初始化器和下标。</li>
<li>不支持继承。</li>
<li>不能遵循 Actor 协议。</li>
<li>不能遵循 AnyObject 协议；如果要添加 Identifiable 协议的遵循，必须自己添加 id 属性。</li>
<li>不能有析构器。</li>
<li>可以直接从外部访问其公共属性和方法。</li>
<li>可能同时执行多个方法。</li>
</ul>
<h2 id="另见"><a class="markdownIt-Anchor" href="#另见"></a> 另见</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/concurrency">Concurrency Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://www.hackingwithswift.com/quick-start/concurrency">Swift Concurrency by Example</a></li>
</ul>
</div><div class="tags"><a href="/tags/Concurrency"><i class="fa fa-tag">Concurrency</i></a></div><div class="post-nav"><a class="pre" href="/newsletter/118/">Kilig 的碎周报 - #118（2024.07.29）</a><a class="next" href="/docker/">Docker 备忘清单</a></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/disqusjs@1.3/dist/disqusjs.css"><script type="text/javascript" src="https://unpkg.com/disqusjs@1.3/dist/disqus.js"></script><script type="text/javascript" id="disqus-count-script">$(function() {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', '//disqus.com/next/config.json', true);
  xhr.timeout = 2500;
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
      $('.post-meta .post-comments-count').show();
      var s = document.createElement('script');
      s.id = 'dsq-count-scr';
      s.src = 'https://kiligwyu.disqus.com/count.js';
      s.async = true;
      (document.head || document.body).appendChild(s);
    }
  };
  xhr.ontimeout = function () { xhr.abort(); };
  xhr.send(null);
});</script><div class="comments" id="disqus_thread"><script type="text/javascript">// Load comments with DisqusJS
function loadComments() {
  window.dsqjs = new DisqusJS({
    shortname: 'kiligwyu',
    siteName: '𝕶𝖎𝖑𝖎𝖌\'𝖘 𝕭𝖑𝖔𝖌',
    identifier: 'concurrency/',
    url: 'http://kiligwyu.com/concurrency/',
    title: 'Concurrency 备忘清单',
    api: '',
    apikey: '',
    admin: 'kiligwyu',
    adminLabel: ''
  });
}
// Lazy load {# Credit: https://github.com/theme-next/hexo-theme-next/blob/master/layout/_third-party/comments/disqus.swig #}
(function () {
  var offsetTop = document.getElementById('disqus_thread').offsetTop - window.innerHeight;
  if (offsetTop <= 0) {
    // Load directly when there's no scrollbar
    window.addEventListener('load', loadComments, false);
  } else {
    var disqusScroll = function () {
      // offsetTop may changes because of manually resizing browser window or lazy loading images
      var offsetTop = document.getElementById('disqus_thread').offsetTop - window.innerHeight;
      var scrollTop = window.scrollY;

      // Pre-load comments a bit? (margin or anything else)
      if (offsetTop - scrollTop < 60) {
        window.removeEventListener('scroll', disqusScroll);
        loadComments();
      }
    };
    window.addEventListener('scroll', disqusScroll);
  }
})();
// Scroll to comments automatically if #comment-xxx anchor specified
window.addEventListener('load', function () {
  // I don't know why, it just works.
  window.setTimeout(function () {
    if (location.hash.indexOf('#comment-') !== -1) {
      document.getElementById('disqus_thread').scrollIntoView(true);
    }
  }, 100);
}, false);
</script></div></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">𝕶𝖎𝖑𝖎𝖌'𝖘 𝕭𝖑𝖔𝖌.</a><br> 豫 ICP 备 404 号 - 1
<br> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>